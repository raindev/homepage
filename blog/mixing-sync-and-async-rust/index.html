
    
        
    


<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width" />
        <title>Mixing Sync and Async Rust - raindev</title>
        <link rel="stylesheet" type="text/css" href="/default.css" />
        <link rel="alternate" type="application/atom+xml" href="/atom.xml"
            title="Atom feed of raindev's blog">
        <link rel="alternate" type="application/rss+xml" href="/rss.xml"
            title="RSS feed of raindev's blog">
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="/">Thoughts and Opinions</a>
            </div>
            <div id="navigation">
                <a href="/about">About</a>
                <a href="/contact">Contact</a>
            </div>
        </div>

        <div id="content">
            <h1>Mixing Sync and Async Rust</h1>

            
<div class="info">
    Posted on 2022-09-15
</div>

<p>Recently I have read <a href="https://openjdk.org/jeps/425">JEP 426</a>, Java enhancement proposal introducing virtual threads - essentially a way to map multiple Java threads to a few operating system threads. I thought it's brilliant, especially the fact that the virtual threads could run <em>unmodified</em> code.</p>
<p>Rust take a different approach to overcoming the scalability issues of operating system threads with asynchronous runtimes and async/await language support. One of the issues however is that the code has to be adapted for the asynchronous model. While async/await syntax significantly improves the experience of writing asynchronous code which is still straightforward to understand, mixing both styles of programming is still very annoying. Or is it really?</p>
<p>Let's look first at running an async function from a normal function. It's a common complaint that depending on a single async function &quot;infects&quot; the code and requires it to be asynchronous all the way. This is not quite the case. Execution an async function requires a runtime and here's how we get one that will run code on the caller thread:</p>
<pre><code>let runtime = tokio::runtime::Builder::new_current_thread()
    .enable_all()
    .build()?
</code></pre>
<p>Now running an async function is quite simple:</p>
<pre><code>let result = runtime.block_on(my_async_function);
</code></pre>
<p>Instead of <a href="https://docs.rs/tokio/latest/tokio/runtime/struct.Builder.html#method.new_current_thread"><code>new_current_thread</code></a> we could use <a href="https://docs.rs/tokio/latest/tokio/runtime/struct.Builder.html#method.new_multi_thread"><code>new_multi_thread</code></a> to get a thread pool runtime that allows to run tasks asynchronously with <a href="https://docs.rs/tokio/latest/tokio/runtime/struct.Runtime.html#method.spawn"><code>Runtime::spawn</code></a> and wait for the completion of tasks with <a href="https://docs.rs/tokio/latest/tokio/runtime/struct.Runtime.html#method.block_on"><code>Runtime::block_on</code></a>.</p>
<p>Alright, this wasn't too bad. What about running synchronous code from an async function? A simple function that does data transformation could be run without any fuss. The problem is code either doing blocking IO or CPU intensive computations as it would block one of the runtime threads and reduce the capacity available to execute async tasks. Thankfully the solution is straightforward:</p>
<pre><code>let resutl = task::spawn_blocking(|| my_slow_http_call()).await?;
</code></pre>
<p><a href="https://docs.rs/tokio/1.21.1/tokio/task/fn.spawn_blocking.html"><code>spawn_blocking</code></a> would execute the task using a dynamically sized thread pool dedicated to blocking tasks.</p>
<p>While it's not the same as being able to run the same code with blocking/asynchronous runtime, mixing the two approaches is not too difficult. If you want to read more on the topic I suggest <a href="https://tokio.rs/tokio/topics/bridging">the Tokio tutorial on bridging with sync code</a>.</p>


        </div>
        <div id="footer">
            <div id="license">
              <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">
                <img alt="Creative Commons License" src="/by-nc-sa.svg"
                  title="The content is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License"/>
              </a>
            </div>
            <div>
                You could subscribe for the updates using
                <a href="/atom.xml">Atom</a>
                or
                <a href="/rss.xml">RSS</a>
                feed
            </div>
            <div>
                Built with <a href="https://getzola.org">Zola</a>.
                The website theme is inspired by
                <a href="http://bettermotherfuckingwebsite.com">this website</a>
            </div>
        </div>
    </body>
</html>
